'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxRunnerVM = void 0;
const common_1 = require("@ethereumjs/common");
const tx_1 = require("@ethereumjs/tx");
const block_1 = require("@ethereumjs/block");
const util_1 = require("@ethereumjs/util");
const eventManager_1 = require("../eventManager");
const logsManager_1 = require("./logsManager");
class TxRunnerVM {
    constructor(vmaccounts, api, getVMObject) {
        this.event = new eventManager_1.EventManager();
        this.logsManager = new logsManager_1.LogsManager();
        // has a default for now for backwards compatability
        this.getVMObject = getVMObject;
        this.commonContext = this.getVMObject().common;
        this.blockNumber = 0;
        this.runAsync = true;
        this.blockNumber = 0; // The VM is running in Homestead mode, which started at this block.
        this.runAsync = false; // We have to run like this cause the VM Event Manager does not support running multiple txs at the same time.
        this.pendingTxs = {};
        this.vmaccounts = vmaccounts;
        this.queusTxs = [];
        this.blocks = [];
        /*
          txHash is generated using the nonce,
          in order to have unique transaction hash, we need to keep using different nonce (in case of a call)
          so we increment this value after each call.
          For this to function we also need to skip nonce validation, in the vm: `{ skipNonce: true }`
        */
        this.nextNonceForCall = 0;
    }
    execute(args, confirmationCb, gasEstimationForceSend, promptCb, callback) {
        let data = args.data;
        if (data.slice(0, 2) !== '0x') {
            data = '0x' + data;
        }
        try {
            this.runInVm(args.from, args.to, data, args.value, args.gasLimit, args.useCall, callback);
        }
        catch (e) {
            callback(e, null);
        }
    }
    runInVm(from, to, data, value, gasLimit, useCall, callback) {
        const self = this;
        let account;
        if (!from && useCall && Object.keys(self.vmaccounts).length) {
            from = Object.keys(self.vmaccounts)[0];
            account = self.vmaccounts[from];
        }
        else
            account = self.vmaccounts[from];
        if (!account) {
            return callback('Invalid account selected');
        }
        this.getVMObject().stateManager.getAccount(util_1.Address.fromString(from)).then((res) => {
            const EIP1559 = this.commonContext.hardfork() !== 'berlin'; // berlin is the only pre eip1559 fork that we handle.
            let tx;
            if (!EIP1559) {
                tx = tx_1.Transaction.fromTxData({
                    nonce: useCall ? this.nextNonceForCall : res.nonce,
                    gasPrice: '0x1',
                    gasLimit: gasLimit,
                    to: to,
                    value: value,
                    data: Buffer.from(data.slice(2), 'hex')
                }, { common: this.commonContext }).sign(account.privateKey);
            }
            else {
                tx = tx_1.FeeMarketEIP1559Transaction.fromTxData({
                    nonce: useCall ? this.nextNonceForCall : res.nonce,
                    maxPriorityFeePerGas: '0x01',
                    maxFeePerGas: '0x1',
                    gasLimit: gasLimit,
                    to: to,
                    value: value,
                    data: Buffer.from(data.slice(2), 'hex')
                }).sign(account.privateKey);
            }
            if (useCall)
                this.nextNonceForCall++;
            const coinbases = ['0x0e9281e9c6a0808672eaba6bd1220e144c9bb07a', '0x8945a1288dc78a6d8952a92c77aee6730b414778', '0x94d76e24f818426ae84aa404140e8d5f60e10e7e'];
            const difficulties = [69762765929000, 70762765929000, 71762765929000];
            const difficulty = this.commonContext.consensusType() === common_1.ConsensusType.ProofOfStake ? 0 : difficulties[self.blockNumber % difficulties.length];
            const block = block_1.Block.fromBlockData({
                header: {
                    timestamp: new Date().getTime() / 1000 | 0,
                    number: self.blockNumber,
                    coinbase: coinbases[self.blockNumber % coinbases.length],
                    difficulty,
                    gasLimit,
                    baseFeePerGas: EIP1559 ? '0x1' : undefined
                },
                transactions: [tx]
            }, { common: this.commonContext });
            if (!useCall) {
                ++self.blockNumber;
                this.runBlockInVm(tx, block, callback);
            }
            else {
                this.getVMObject().stateManager.checkpoint().then(() => {
                    this.runBlockInVm(tx, block, (err, result) => {
                        this.getVMObject().stateManager.revert().then(() => {
                            callback(err, result);
                        });
                    });
                });
            }
        }).catch((e) => {
            callback(e);
        });
    }
    runBlockInVm(tx, block, callback) {
        this.getVMObject().vm.runBlock({ block: block, generate: true, skipBlockValidation: true, skipBalance: false, skipNonce: true }).then((results) => {
            const result = results.results[0];
            callback(null, {
                result,
                transactionHash: (0, util_1.bufferToHex)(Buffer.from(tx.hash())),
                block,
                tx
            });
        }).catch(function (err) {
            callback(err);
        });
    }
}
exports.TxRunnerVM = TxRunnerVM;
//# sourceMappingURL=txRunnerVM.js.map